// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"flag"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"text/template"

	"golang.org/x/tools/go/packages"
)

var (
	flagFunc = flag.String("func", "Fuzz", "fuzzer entry point")
	flagTags = flag.String("tags", "", "a comma-separated list of build tags to consider satisfied during the build")
	flagO    = flag.String("o", "", "output file")
)

func main() {
	flag.Parse()

	if !token.IsIdentifier(*flagFunc) || !token.IsExported(*flagFunc) {
		log.Fatal("-func must be an exported identifier")
	}

	out := *flagO
	if out == "" {
		log.Fatal("-o must point to an output file")
	}

	tags := "libfuzzer"
	if *flagTags != "" {
		tags += "," + *flagTags
	}

	buildFlags := []string{
		"-buildmode", "c-archive",
		"-gcflags", "all=-d=libfuzzer",
		"-tags", tags,
		"-trimpath",
	}

	pkgs, err := packages.Load(&packages.Config{
		Mode:       packages.NeedName,
		BuildFlags: buildFlags,
	}, flag.Args()...)
	if err != nil {
		log.Fatal("failed to load packages:", err)
	}
	if len(pkgs) != 1 {
		log.Fatal("specified more than one package")
	}
	pkg := pkgs[0]

	mainFile, err := ioutil.TempFile(".", "main.*.go")
	if err != nil {
		log.Fatal("failed to create temporary file:", err)
	}
	defer os.Remove(mainFile.Name())

	type Data struct {
		PkgPath  string
		FuzzFunc string
	}
	err = mainTmpl.Execute(mainFile, &Data{
		PkgPath:  pkg.PkgPath,
		FuzzFunc: *flagFunc,
	})
	if err != nil {
		log.Fatal("failed to execute template:", err)
	}
	if err := mainFile.Close(); err != nil {
		log.Fatal("failed to close temporary file:", err)
	}

	args := []string{"build", "-o", out}
	args = append(args, buildFlags...)
	args = append(args, mainFile.Name())
	cmd := exec.Command("go", args...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		log.Fatal("failed to build package:", err)
	}
}

var mainTmpl = template.Must(template.New("main").Parse(`
// Code generated by go-fuzz; DO NOT EDIT.
// +build ignore
package main

import (
  "reflect"
	"unsafe"
	target {{printf "%q" .PkgPath}}
)

// #include <stdint.h>
import "C"

//export LLVMFuzzerInitialize
func LLVMFuzzerInitialize(argc uintptr, argv uintptr) int {
	return 0
}

//export LLVMFuzzerTestOneInput
func LLVMFuzzerTestOneInput(data uintptr, size uint64) int {
	sh := &reflect.SliceHeader{
		Data: data,
		Len:  int(size),
		Cap:  int(size),
	}

	input := *(*[]byte)(unsafe.Pointer(sh))
	target.{{.FuzzFunc}}(input)

	return 0
}

func main() {
}
`))
