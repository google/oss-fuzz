"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setParameterResolverValue = exports.ParameterResolverIndex = exports.defaultOptions = exports.buildOptions = exports.FuzzedDataProvider = exports.wrapFuzzFunctionForBugDetection = exports.startFuzzingNoInit = exports.startFuzzing = exports.initFuzzing = void 0;
/*
 * Copyright 2023 Code Intelligence GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const path_1 = __importDefault(require("path"));
const tmp = __importStar(require("tmp"));
const fs = __importStar(require("fs"));
const libCoverage = __importStar(require("istanbul-lib-coverage"));
const libReport = __importStar(require("istanbul-lib-report"));
const reports = __importStar(require("istanbul-reports"));
const fuzzer = __importStar(require("@jazzer.js/fuzzer"));
const hooking = __importStar(require("@jazzer.js/hooking"));
const finding_1 = require("./finding");
const instrumentor_1 = require("@jazzer.js/instrumentor");
const callback_1 = require("./callback");
const utils_1 = require("./utils");
const options_1 = require("./options");
// Remove temporary files on exit
tmp.setGracefulCleanup();
// libFuzzer uses exit code 77 in case of a crash, so use a similar one for
// failed error expectations.
const ERROR_EXPECTED_CODE = 0;
const ERROR_UNEXPECTED_CODE = 78;
const SIGSEGV = 11;
async function initFuzzing(options) {
    registerGlobals(options);
    (0, instrumentor_1.registerInstrumentor)(new instrumentor_1.Instrumentor(options.includes, options.excludes, options.customHooks, options.coverage, options.dryRun, options.idSyncFile
        ? new instrumentor_1.FileSyncIdStrategy(options.idSyncFile)
        : new instrumentor_1.MemorySyncIdStrategy()));
    // Dynamic import works only with javascript files, so we have to manually specify the directory with the
    // transpiled bug detector files.
    const possibleBugDetectorFiles = getFilteredBugDetectorPaths(path_1.default.join(__dirname, "../../bug-detectors/dist/internal"), options.disableBugDetectors);
    if (process.env.JAZZER_DEBUG) {
        console.error("INFO: [BugDetector] Loading bug detectors: \n   " +
            possibleBugDetectorFiles.join("\n   "));
    }
    // Load bug detectors before loading custom hooks because some bug detectors can be configured in the
    // custom hooks file.
    await Promise.all(possibleBugDetectorFiles.map(utils_1.ensureFilepath).map(utils_1.importModule));
    await Promise.all(options.customHooks.map(utils_1.ensureFilepath).map(utils_1.importModule));
    await hooking.hookManager.finalizeHooks();
}
exports.initFuzzing = initFuzzing;
function registerGlobals(options) {
    globalThis.Fuzzer = fuzzer.fuzzer;
    globalThis.HookManager = hooking.hookManager;
    globalThis.options = options;
}
// Filters out disabled bug detectors and prepares all the others for dynamic import.
// This functionality belongs to the bug-detector module but no dependency from
// core to bug-detectors is allowed.
function getFilteredBugDetectorPaths(bugDetectorsDirectory, disableBugDetectors) {
    const disablePatterns = disableBugDetectors.map((pattern) => new RegExp(pattern));
    return (fs
        .readdirSync(bugDetectorsDirectory)
        // The compiled "internal" directory contains several files such as .js.map and .d.ts.
        // We only need the .js files.
        // Here we also filter out bug detectors that should be disabled.
        .filter((bugDetectorPath) => {
        if (!bugDetectorPath.endsWith(".js")) {
            return false;
        }
        // Dynamic imports need .js files.
        const bugDetectorName = path_1.default.basename(bugDetectorPath, ".js");
        // Checks in the global options if the bug detector should be loaded.
        const shouldDisable = disablePatterns.some((pattern) => pattern.test(bugDetectorName));
        if (shouldDisable) {
            console.error(`Skip loading bug detector "${bugDetectorName}" because of user-provided pattern.`);
        }
        return !shouldDisable;
    })
        // Get absolute paths for each bug detector.
        .map((file) => path_1.default.join(bugDetectorsDirectory, file)));
}
async function startFuzzing(options) {
    await initFuzzing(options);
    const fuzzFn = await loadFuzzFunction(options);
    await startFuzzingNoInit(fuzzFn, options).then(() => {
        stopFuzzing(undefined, options.expectedErrors, options.coverageDirectory, options.coverageReporters, options.sync);
    }, (err) => {
        stopFuzzing(err, options.expectedErrors, options.coverageDirectory, options.coverageReporters, options.sync);
    });
}
exports.startFuzzing = startFuzzing;
async function startFuzzingNoInit(fuzzFn, options) {
    // Signal handler that stops fuzzing when the process receives a SIGINT/SIGSEGV,
    // necessary to generate coverage reports and print debug information.
    // The handler stops the process via `stopFuzzing`, as resolving the "fuzzing
    // promise" does not work in sync mode due to the blocked event loop.
    const signalHandler = (exitCode) => {
        stopFuzzing(undefined, options.expectedErrors, options.coverageDirectory, options.coverageReporters, options.sync, exitCode);
    };
    const fuzzerOptions = (0, options_1.buildFuzzerOption)(options);
    if (options.sync) {
        return Promise.resolve().then(() => Fuzzer.startFuzzing(fuzzFn, fuzzerOptions, 
        // In synchronous mode, we cannot use the SIGINT/SIGSEGV handler in Node,
        // because it won't be called until the fuzzing process is finished.
        // Hence, we pass a callback function to the native fuzzer.
        // The appropriate exitCode for the signalHandler will be added by the native fuzzer.
        signalHandler));
    }
    else {
        process.on("SIGINT", () => signalHandler(0));
        process.on("SIGSEGV", () => signalHandler(SIGSEGV));
        return Fuzzer.startFuzzingAsync(fuzzFn, fuzzerOptions);
    }
}
exports.startFuzzingNoInit = startFuzzingNoInit;
function stopFuzzing(err, expectedErrors, coverageDirectory, coverageReporters, sync, forceShutdownWithCode) {
    const stopFuzzing = sync ? Fuzzer.stopFuzzing : Fuzzer.stopFuzzingAsync;
    if (process.env.JAZZER_DEBUG) {
        hooking.hookTracker.categorizeUnknown(HookManager.hooks).print();
    }
    // Generate a coverage report in fuzzing mode (non-jest). The coverage report for our jest-runner is generated
    // by jest internally (as long as '--coverage' is set).
    if (global.__coverage__) {
        const coverageMap = libCoverage.createCoverageMap(global.__coverage__);
        const context = libReport.createContext({
            dir: coverageDirectory,
            watermarks: {},
            coverageMap: coverageMap,
        });
        coverageReporters.forEach((reporter) => reports.create(reporter).execute(context));
    }
    // Prioritize findings over segfaults.
    if (forceShutdownWithCode === SIGSEGV && !(err instanceof finding_1.Finding)) {
        err = new finding_1.Finding("Segmentation Fault");
    }
    // No error found, check if one is expected or an exit code should be enforced.
    if (!err) {
        if (expectedErrors.length) {
            console.error(`ERROR: Received no error, but expected one of [${expectedErrors}].`);
            stopFuzzing(ERROR_UNEXPECTED_CODE);
        }
        else if (forceShutdownWithCode === 0) {
            stopFuzzing(forceShutdownWithCode);
        }
        return;
    }
    // Error found and expected, check if it's one of the expected ones.
    if (expectedErrors.length) {
        const name = errorName(err);
        if (expectedErrors.includes(name)) {
            console.error(`INFO: Received expected error "${name}".`);
            stopFuzzing(ERROR_EXPECTED_CODE);
        }
        else {
            (0, finding_1.printFinding)(err);
            console.error(`ERROR: Received error "${name}" is not in expected errors [${expectedErrors}].`);
            stopFuzzing(ERROR_UNEXPECTED_CODE);
        }
        return;
    }
    // Error found, but no specific one expected. This case is used for normal
    // fuzzing runs, so no dedicated exit code is given to the stop fuzzing function.
    (0, finding_1.printFinding)(err);
    stopFuzzing();
}
function errorName(error) {
    if (error instanceof Error) {
        // error objects
        return error.name;
    }
    else if (typeof error !== "object") {
        // primitive types
        return String(error);
    }
    else {
        // Arrays and objects can not be converted to a proper name and so
        // not be stated as expected error.
        return "unknown";
    }
}
async function loadFuzzFunction(options) {
    const fuzzTarget = await (0, utils_1.importModule)(options.fuzzTarget);
    if (!fuzzTarget) {
        throw new Error(`${options.fuzzTarget} could not be imported successfully"`);
    }
    const fuzzFn = fuzzTarget[options.fuzzEntryPoint];
    if (typeof fuzzFn !== "function") {
        throw new Error(`${options.fuzzTarget} does not export function "${options.fuzzEntryPoint}"`);
    }
    return wrapFuzzFunctionForBugDetection(fuzzFn);
}
/**
 * Wraps the given fuzz target function to handle errors from both the fuzz target and bug detectors.
 * Ensures that errors thrown by bug detectors have higher priority than errors in the fuzz target.
 */
function wrapFuzzFunctionForBugDetection(originalFuzzFn) {
    function throwIfError(fuzzTargetError) {
        const error = (0, finding_1.getFirstFinding)();
        if (error !== undefined) {
            // The `firstFinding` is a global variable: we need to clear it after each fuzzing iteration.
            (0, finding_1.clearFirstFinding)();
            throw error;
        }
        else if (fuzzTargetError) {
            throw fuzzTargetError;
        }
        return undefined;
    }
    if (originalFuzzFn.length === 1) {
        return (data) => {
            let fuzzTargetError;
            let result = undefined;
            try {
                callback_1.callbacks.runBeforeEachCallbacks();
                result = originalFuzzFn(data);
                // Explicitly set promise handlers to process findings, but still return
                // the fuzz target result directly, so that sync execution is still
                // possible.
                if (result instanceof Promise) {
                    result = result.then((result) => {
                        callback_1.callbacks.runAfterEachCallbacks();
                        return throwIfError() ?? result;
                    }, (reason) => {
                        return throwIfError(reason);
                    });
                }
            }
            catch (e) {
                fuzzTargetError = e;
            }
            // Promises are handled above, so we only need to handle sync results here.
            if (!(result instanceof Promise)) {
                callback_1.callbacks.runAfterEachCallbacks();
            }
            return throwIfError(fuzzTargetError) ?? result;
        };
    }
    else {
        return (data, done) => {
            let result = undefined;
            try {
                callback_1.callbacks.runBeforeEachCallbacks();
                // Return result of fuzz target to enable sanity checks in C++ part.
                result = originalFuzzFn(data, (err) => {
                    const finding = (0, finding_1.getFirstFinding)();
                    if (finding !== undefined) {
                        (0, finding_1.clearFirstFinding)();
                    }
                    callback_1.callbacks.runAfterEachCallbacks();
                    done(finding ?? err);
                });
            }
            catch (e) {
                callback_1.callbacks.runAfterEachCallbacks();
                throwIfError(e);
            }
            return result;
        };
    }
}
exports.wrapFuzzFunctionForBugDetection = wrapFuzzFunctionForBugDetection;
// Export public API from within core module for easy access.
__exportStar(require("./api"), exports);
var FuzzedDataProvider_1 = require("./FuzzedDataProvider");
Object.defineProperty(exports, "FuzzedDataProvider", { enumerable: true, get: function () { return FuzzedDataProvider_1.FuzzedDataProvider; } });
var options_2 = require("./options");
Object.defineProperty(exports, "buildOptions", { enumerable: true, get: function () { return options_2.buildOptions; } });
Object.defineProperty(exports, "defaultOptions", { enumerable: true, get: function () { return options_2.defaultOptions; } });
Object.defineProperty(exports, "ParameterResolverIndex", { enumerable: true, get: function () { return options_2.ParameterResolverIndex; } });
Object.defineProperty(exports, "setParameterResolverValue", { enumerable: true, get: function () { return options_2.setParameterResolverValue; } });
//# sourceMappingURL=core.js.map