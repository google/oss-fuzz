diff --git a/src/blockdata.c b/src/blockdata.c
index 4c26155..9612447 100644
--- a/src/blockdata.c
+++ b/src/blockdata.c
@@ -15,18 +15,24 @@
 */
 
 #include "dnsmasq.h"
+#include <assert.h>
 
 static struct blockdata *keyblock_free;
 static unsigned int blockdata_count, blockdata_hwm, blockdata_alloced;
 
+void *total_allocated[200] = {0};
+static int fuzz_total_alloc_ptr = 0;
+
 static void add_blocks(int n)
 {
   struct blockdata *new = whine_malloc(n * sizeof(struct blockdata));
   
   if (new)
     {
+      assert(fuzz_total_alloc_ptr < 200);
+      total_allocated[fuzz_total_alloc_ptr++] = (void*)new;
       int i;
       
       new[n-1].next = keyblock_free;
       keyblock_free = new;
 
@@ -45,11 +51,23 @@
   blockdata_count = 0;
   blockdata_hwm = 0;
 
+  fuzz_total_alloc_ptr = 0;
+  for (int m = 0; m < 200; m++)
+	  total_allocated[m] = NULL;
+
   /* Note that daemon->cachesize is enforced to have non-zero size if OPT_DNSSEC_VALID is set */  
   if (option_bool(OPT_DNSSEC_VALID))
     add_blocks(daemon->cachesize);
 }
 
+void fuzz_blockdata_cleanup() {
+	for (int i = 0; i < 200; i++) {
+		if (total_allocated[i] != NULL) {
+			free(total_allocated[i]);
+		}
+	}
+}
+
 void blockdata_report(void)
 {
   my_syslog(LOG_INFO, _("pool memory in use %zu, max %zu, allocated %zu"), 
diff --git a/src/dhcp.c b/src/dhcp.c
index 6104c87..0a42ac3 100644
--- a/src/dhcp.c
+++ b/src/dhcp.c
@@ -186,7 +186,13 @@ void dhcp_packet(time_t now, int pxe_fd)
     recvtime = tv.tv_sec;
   
   if (msg.msg_controllen >= sizeof(struct cmsghdr))
-    for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
+  {
+    int tmp_val = 0;
+    for (cmptr = CMSG_FIRSTHDR(&msg);
+         cmptr && tmp_val < 1;
+	 tmp_val++) {
+	 //cmptr = CMSG_NXTHDR(&msg, cmptr)) {
+      tmp_val++;
       if (cmptr->cmsg_level == IPPROTO_IP && cmptr->cmsg_type == IP_PKTINFO)
 	{
 	  union {
@@ -198,6 +204,8 @@ void dhcp_packet(time_t now, int pxe_fd)
 	  if (p.p->ipi_addr.s_addr != INADDR_BROADCAST)
 	    unicast_dest = 1;
 	}
+    }
+  }
 
 #elif defined(HAVE_BSD_NETWORK) 
   if (msg.msg_controllen >= sizeof(struct cmsghdr))
diff --git a/src/dhcp6.c b/src/dhcp6.c
index edb87a4..937b5a7 100644
--- a/src/dhcp6.c
+++ b/src/dhcp6.c
@@ -118,7 +118,9 @@
   if ((sz = recv_dhcp_packet(daemon->dhcp6fd, &msg)) == -1)
     return;
   
-  for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
+  int tmp_val = 0;
+  for (cmptr = CMSG_FIRSTHDR(&msg); cmptr && tmp_val < 1; tmp_val++) {
+         tmp_val++;
     if (cmptr->cmsg_level == IPPROTO_IPV6 && cmptr->cmsg_type == daemon->v6pktinfo)
       {
    union {
@@ -130,9 +132,11 @@
    if_index = p.p->ipi6_ifindex;
    dst_addr = p.p->ipi6_addr;
       }
+  }
 
-  if (!indextoname(daemon->dhcp6fd, if_index, ifr.ifr_name))
+  if (!indextoname(daemon->dhcp6fd, if_index, ifr.ifr_name)) {
     return;
+  }
   
 #ifdef HAVE_LINUX_NETWORK
   /* This works around a possible Linux kernel bug when using interfaces
diff --git a/src/netlink.c b/src/netlink.c
index da82943..819b3c0 100644
--- a/src/netlink.c
+++ b/src/netlink.c
@@ -190,8 +190,13 @@ int iface_enumerate(int family, void *parm, int (*callback)())
   if (errno != 0)
     return 0;
     
+  int valval = 0;
   while (1)
     {
+      valval++;
+      if (valval > 300) {
+        return -1;
+      }
       if ((len = netlink_recv(0)) == -1)
 	{
 	  if (errno == ENOBUFS)
diff --git a/src/network.c b/src/network.c
index 4453b05..3740cf3 100644
--- a/src/network.c
+++ b/src/network.c
@@ -696,6 +696,7 @@ int enumerate_interfaces(int reset)
   struct auth_zone *zone;
 #endif
   struct server *serv;
+  int iteration = 0;
   
   /* Do this max once per select cycle  - also inhibits netlink socket use
    in TCP child processes. */
@@ -733,6 +734,10 @@ int enumerate_interfaces(int reset)
       }
     
 again:
+  if (iteration > 100) {
+    return 0;
+  }
+  iteration += 1;
   /* Mark interfaces for garbage collection */
   for (iface = daemon->interfaces; iface; iface = iface->next) 
     iface->found = 0;
